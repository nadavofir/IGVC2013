/*
 * ocean_server_imu_publisher.cpp
 *
 *      Author: Joshua James, Nicu Stiurca, Robby Nevels
 */

// standard library includes
#include <string>
#include <sstream>
#include <iostream>

// boost library includes
#include <boost/asio/serial_port.hpp>
#include <boost/iostreams/stream.hpp>

// ros
#include <ros/ros.h>

using namespace std;

/// copied from
/// http://groups.google.com/group/boost-list/browse_thread/thread/7c271c4269bd0f93

class serial_device
{
public:
  typedef char char_type;
  typedef boost::iostreams::bidirectional_device_tag category;
  serial_device(boost::asio::serial_port& port) :
  serial_port_(port)
  {
  }

  std::streamsize read(char* buf, std::streamsize n)
  {
    boost::system::error_code ec;
    int len = serial_port_.read_some(boost::asio::buffer(buf, n), ec);
    if (ec) {
      printf("ERROR CODE %d\n",ec);
    }
    return len;
  }
  std::streamsize write(const char* buf, std::streamsize n)
  {
    return serial_port_.write_some(boost::asio::buffer(buf, n));
  }
private:
  boost::asio::serial_port& serial_port_;
};

typedef boost::iostreams::stream<serial_device> serial_stream;

void timerTest() {
  ros::Rate r(2);
  for(int i = 0; i < 10; i++) {
    cout << i << "...";
    r.sleep();
  }
}

void USBReadTest() {
  boost::asio::io_service io;
  boost::asio::serial_port port(io, "/dev/ucontroller");
  port.set_option(boost::asio::serial_port_base::baud_rate(115200));
  serial_device device(port);
  serial_stream stream(device);

  int i = 0, j;
  while(true) {
    char str[128];
    printf("READING %i...\n",i);
    int len = device.read(str, 128);
    printf("read %d bytes:\n",len);
    printf("[\n %s \n]\n\n",str);
    i++;
    for(j = 0; j < 1024; j++)
      str[j] = 0;
  }
}

void USBReadTest2() {
    io_service io;
    serial_port port( io, PORT );

    port.set_option( serial_port_base::baud_rate BAUD(115200); );
    //port.set_option( CSIZE );
    //port.set_option( FLOW );
    //port.set_option( PARITY );
    //port.set_option( STOP );

    // buffer to store commands
    // this device reads 8 bits, meaning an unsigned char, as instructions
    // varies with the device, check the manual first
    unsigned char command[1] = {0};

    // read in user value to be sent to device
    int input;
    cin >> input;

    // Simple loop, since the only good values are [0,255]
    //  break when a negative number is entered.
    // The cast will convert too big numbers into range.
    while( input >= 0 )
    {
      // convert our read in number into the target data type
      command[0] = static_cast<unsigned char>( input );

      // this is the command that sends the actual bits over the wire
      // note it takes a stream and a asio::buffer
      // the stream is our serial_port
      // the buffer is constructed using our command buffer and
      //  the number of instructions to send
      write( port, buffer( command, 1 ) );

      // read in the next input value
      cin >> input;
    }
}

int main(int argc, char** argv)
{
  ros::init(argc, argv, "uszynski_the_ucontroller");
  ros::Time::init();
  USBReadTest2();
}
